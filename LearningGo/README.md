####  Go语言诞生背景
1. 多核服务器成为主流，GO能更好的发挥多核CPU的威力
2. 程序规模变大后快速编译程序
3. 编程语法更加优雅

---

#### Go语言特性
1. 基础语法
	1. 25个关键字
2. 类型系统
	1. 静态语言，支持运行时动态类型
	2. 强类型语言
	3. 支持隐式类型推导(通过:=定义变量即可自动响应类型)
	4. 类型安全
	5. 支持type自定义
3. 抽象
	1. 支持函数
	2. 类型组合支持面向对象
	3. Duck模型接口
	4. 多态通过接口支持
4. 元编程
	1. 不支持泛型
	2. 支持反射
5. 平台和运行模式
	1. 编译成可执行程序
	2. OS直接运行
	3. 支持自动垃圾回收
	4. 原生支持并发（协程）
	5. 支持交叉编译
	6. 支持跨平台
6. 语言软实力
	1. 标准库与第三方库丰富且发展很快
	2. 框架丰富且发展很快
	3. 语言向前兼容性好
	4. 社区活跃，诞生于Google
	5. 应用于云计算基础设施软件、中间件、区块链

---
#### Go词法单元
见interpretation文件夹

---
#### 变量和常量
变量和常量区别方法是指向的内存是否可以被修改
- 变量
使用一个名称来绑定一块内存地址，存放的数据类型由定义变量的时候指定的类型决定，内存地址中存放的内容可以改变
1. 显示的完整声明
	`var aaa string (= "abc")`
2. 短类型声明
	`aaa := "abc"`
Go支持多变量同时声明
	`a, b := 1, "abc"`

- 常量
使用一个名称来绑定一块内存地址，存放的数据类型由定义常量时指定的类型决定，内存地址中存放的内容不可以改变，常量存储在程序的只读段里

---

#### 数据类型
类型是高级语言的基础，有了类型，高级语言才能对不同类型抽象出不同的运算，编程者才能在更高的抽象层次上操纵数据，而不用关注具体存储和运算细节
- 布尔类型
布尔型数据和整型数据不能互相转换
声明的布尔型变量如果不指定初始化值，默认为false
- 整型
GO中不同类型的整型必须进行强制转换
- 浮点型
浮点型如果使用:=赋值，会自动推断为float64
两个浮点数进行比较时不应该使用==或!=，应该使用math标准库
- 复数
复数在计算机中使用两个浮点数表示，complex64由两个float32构成，complex128由两个float64构成real方法返回实部，image方法返回虚部
- 字符串
字符串是常量，可以通过索引访问字节单元，不能修改某个字节的值
可以切片，但是要慎用，尤其是数据量较大时（因为转换时要复制内容）
字符串尾部不包含NULL
底层是一个二元数据结构，一个指针指向字节数组起点，另一个是长度
对于字符串创建的切片，依然是字符串，且与原字符串指向相同的底层字符数组，返回的是string，而不是slice
字符串可以转换为字节数组，也可以转换为Unicode的字数组
字符串用+拼接，可以用for进行遍历，字节数组用for，rune数组用for，range
- rune
在底层是int32的别名
- 复合数据类型
基本的复合数据类型有：指针，数组，切片，字典，通道，结构体，接口
- 指针
声明类型为*T,也支持多级指针**T，使用&来取地址
GO没有->操作符，一律用.
GO不支持指针运算
函数中允许返回局部变量地址
- 数组
数组创建完长度就固定了，不可以再追加元素
数组是值类型
数组长度也是类型的一部分，不同长度同种数据类型的数组表示不同的类型
可以根据数组创建切片
- 切片
切片维护三个元素，指向底层数组的指针，切片的长度，切片的容量
切片可以根据已有数组按照索引创建
切面如果通过make创建，使用make创建的切片默认每个元素都为0
直接声明切片是没有意义的，输出结果是[]，底层数组是nil
切片可以通过append增加元素，通过copy复制切片
- map
map[K]T，map的key=>K必须是可以进行判等操作的类型，T是值类型，map是一种引用类型
可以用range遍历一个map，但是不保证每次迭代元素的顺序
删除map的某个键值要用delete函数
map不是并发安全的，sync包中的map是并发安全的
如想变更某个value，必须整体替换，不能通过引用直接修改
- 结构体
结构体的类型可以使任意类型
结构体的存储空间是连续的，其字段按照声明时的顺序存放
struct有字面量，但是实际应用时不常用，多数都是通过type自定义新类型

---
#### 控制结构
控制结构基本有两种：顺序和跳转
顺序就是按照存放顺序逐条执行
跳转是遇到跳转指令就跳转到某处继续线性执行
跳转又分两种：无条件跳转（如函数调用、goto语句），有条件跳转（如分支、循环）
- if语句
if后面的语句不需要小括号
花括号（{}）的开头比方和if放在一行
if后面可以初始化变量，并以分号分割，且变量作用域是整个if语句块，包括后面的else if和else
GO没有三元运算
遇到return直接返回
	- 尽量减少条件语句复杂度，如果太复杂建议用函数封装
	- 尽量减少if语句嵌套层次
- switch语句
switch语句后面也可以初始化变量
switch后面可以不加表达式，如果不加表达式，则case语句是一个布尔表达式，而不是一个值
switch表达式的值可以使任何支持判等操作的类型变量
通过fallthough语句强国之执行下一个case语句，且不判断下一个case的条件是否满足
switch支持default语句
- for循环
GO中的for有三种用法
1. `for init; condition; post {}`相当于C语言的for循环
2. `for condition {}`相当于C语言的while循环
3. `for {}`死循环
for还有一种就是配合range对数组、切片、字符串、map、channel进行访问

---
#### 函数
GO中函数的可见性由函数名首字母大小写控制，大写时其他包可见，小写时其他包不可见
函数可以没有输入参数，也可以没有返回值（没有返回值默认返回0）
多个相邻的相同类型参数可以使用简写模式（a,b int）
函数返回值可以有变量名，参数名相当于函数体内最外层的局部变量，且返回值变量会被初始化为零值
不支持缺省值
不支持函数重载
不支持函数嵌套（仅针对于明明函数，如果函数体内的函数是匿名函数则可以支持）
多返回值的时候一定要用（）包裹（如（int,int））
如果多值中有错误类型，一般讲错误类型作为最后一个返回值
GO的函数支持不定参数，使用param ...type方式
不定参数类型必须相同
不定参数必须是函数的最后一个参数
不定参数在函数中相当于切片
切片可以作为参数传递给不定参数，切片名后面要加上"..."
形参为不定参数的函数和形参为切片的函数类型不相同

